/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => InfostackerPlugin
});
var import_obsidian3 = __toModule(require("obsidian"));

// src/infostacker.ts
var import_obsidian = __toModule(require("obsidian"));

// src/helpers.js
var import_stream = __toModule(require("stream"));
var import_util = __toModule(require("util"));

// src/errors.ts
var FileSizeLimitError = class extends Error {
  constructor(message = "File size exceeds the specified limit") {
    super(message);
    this.name = "FileSizeLimitError";
  }
};

// src/helpers.js
var FILE_SIZE_LIMIT = 25 * 1024 * 1024;
async function streamToString(data) {
  const reader = data.getReader();
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done)
      break;
    chunks.push(value);
  }
  return Buffer.concat(chunks).toString("utf-8");
}
function isErrored(body) {
  return !!(body && (import_stream.isErrored ? (0, import_stream.isErrored)(body) : /state: 'errored'/.test((0, import_util.inspect)(body))));
}
function isBuffer(buffer) {
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
}
async function extractBody(object, newBoundary) {
  let source = null;
  let length = 0;
  const boundary = newBoundary || `formdata-boundary`;
  const rn = new Uint8Array([13, 10]);
  const blobParts = [];
  for (const [name, value] of object) {
    if (typeof value === "string") {
      const header = `--${boundary}\r
Content-Disposition: form-data; name="${name}"\r
\r
`;
      const chunk = new TextEncoder().encode(header + value + "\r\n");
      blobParts.push(chunk);
      length += chunk.byteLength;
    } else {
      const header = `--${boundary}\r
Content-Disposition: form-data; name="${name}"${value.name ? `; filename="${value.name}"` : ""}\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
      const chunk = new TextEncoder().encode(header);
      blobParts.push(chunk);
      if (value instanceof Blob) {
        const buffer = await value.arrayBuffer();
        const bufferSize = buffer.byteLength;
        if (bufferSize > FILE_SIZE_LIMIT) {
          throw new FileSizeLimitError();
        }
        const base64Data = Buffer.from(buffer).toString("base64");
        const chunkSize = 1e6;
        for (let i = 0; i < base64Data.length; i += chunkSize) {
          const base64Chunk = base64Data.slice(i, i + chunkSize);
          const encodedChunk = new TextEncoder().encode(base64Chunk);
          blobParts.push(encodedChunk);
          length += encodedChunk.byteLength;
        }
      } else {
        if (value.size > FILE_SIZE_LIMIT) {
          throw new FileSizeLimitError();
        }
        blobParts.push(value);
        length += value.size;
      }
      blobParts.push(rn);
      length += chunk.byteLength + rn.byteLength;
    }
  }
  const finalChunk = new TextEncoder().encode(`--${boundary}--\r
`);
  blobParts.push(finalChunk);
  length += finalChunk.byteLength;
  const action = async function* () {
    for (const part of blobParts) {
      if (part instanceof Uint8Array || part instanceof ArrayBuffer) {
        yield part;
      } else if (part.stream) {
        const reader = part.stream().getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          yield value;
        }
      }
    }
  };
  const type = `multipart/form-data; boundary=${boundary}`;
  if (typeof source === "string" || isBuffer(source)) {
    length = Buffer.byteLength(source);
  }
  let iterator;
  const stream = new ReadableStream({
    async start() {
      iterator = action()[Symbol.asyncIterator]();
    },
    async pull(controller) {
      const { value, done } = await iterator.next();
      if (done) {
        queueMicrotask(() => {
          controller.close();
        });
      } else if (!isErrored(stream)) {
        controller.enqueue(new Uint8Array(value));
      }
      return controller.desiredSize > 0;
    },
    async cancel() {
      await iterator.return();
    },
    type: void 0
  });
  return {
    body: {
      stream,
      source,
      length
    },
    type
  };
}
async function formDataToString(form, boundary) {
  const { body: { stream } } = await extractBody(form, boundary);
  return streamToString(stream);
}

// src/infostacker.ts
var baseUrl = "https://shr.infostacker.com";
var infostackerWrapper = {
  async createPost(formData) {
    const boundary = "formdata-" + Math.random().toString(36).substring(2, 17);
    const response = await (0, import_obsidian.requestUrl)({
      url: `${baseUrl}/sharing/uploadmarkdownwithfiles`,
      method: `POST`,
      contentType: `multipart/form-data; boundary=${boundary}`,
      body: await formDataToString(formData, boundary)
    });
    return response.json;
  },
  async updatePost(id, formData) {
    const boundary = "formdata-" + Math.random().toString(36).substring(2, 17);
    const response = await (0, import_obsidian.requestUrl)({
      url: `${baseUrl}/sharing/${id}`,
      method: `PUT`,
      contentType: `multipart/form-data; boundary=${boundary}`,
      body: await formDataToString(formData, boundary)
    });
    return response.json;
  },
  async deletePost(id, formData) {
    const boundary = "formdata-" + Math.random().toString(36).substring(2, 17);
    const response = await (0, import_obsidian.requestUrl)({
      url: `${baseUrl}/sharing/${id}`,
      method: `DELETE`,
      contentType: `multipart/form-data; boundary=${boundary}`,
      body: await formDataToString(formData, boundary)
    });
    return response.json;
  }
};
async function createClient(loadData, saveData) {
  const data = await loadData();
  return {
    data() {
      return data;
    },
    async publishPost(file) {
      if (data.posts[file.path]) {
        await this.updatePost(file);
        return null;
      } else {
        return await this.createPost(file);
      }
    },
    async createPost(file) {
      const title = file.basename;
      const fileContent = await file.vault.read(file);
      const content = `${title}

${fileContent}`;
      const attachmentPaths = this.extractAttachmentPaths(content);
      const formData = new FormData();
      formData.append("markdown", content);
      const findFileInSubdirectories = async (vault, filename) => {
        const searchInDirectory = async (directory) => {
          for (const child of directory.children) {
            if (child instanceof import_obsidian.TFile && child.name === filename) {
              return child;
            } else if (child instanceof import_obsidian.TFolder) {
              const result = await searchInDirectory(child);
              if (result)
                return result;
            }
          }
          return null;
        };
        return await searchInDirectory(vault.getRoot());
      };
      for (const path of attachmentPaths) {
        let attachmentFile = file.vault.getAbstractFileByPath(path);
        if (!(attachmentFile instanceof import_obsidian.TFile)) {
          const filename = path.split("/").pop();
          attachmentFile = await findFileInSubdirectories(file.vault, filename);
        }
        if (attachmentFile instanceof import_obsidian.TFile) {
          try {
            const attachmentContent = await attachmentFile.vault.readBinary(attachmentFile);
            const attachmentBlob = new Blob([attachmentContent]);
            formData.append("files", attachmentBlob, attachmentFile.name);
          } catch (e) {
            console.error(`Failed to read attachment: ${path}`, e);
          }
        }
      }
      try {
        const resp = await infostackerWrapper.createPost(formData);
        data.posts[file.path] = {
          id: resp.id,
          secret: resp.secret
        };
        await saveData(data);
        return `${baseUrl}/sharing/${resp.id}`;
      } catch (e) {
        console.error(e);
        if (e instanceof FileSizeLimitError) {
          throw new FileSizeLimitError("Failed to create post");
        } else {
          throw new Error("Failed to create post");
        }
      }
    },
    getUrl(file) {
      const post = data.posts[file.path];
      if (!post) {
        return null;
      }
      return `${baseUrl}/sharing/${post.id}`;
    },
    async updatePost(file) {
      const post = data.posts[file.path];
      const title = file.basename;
      const fileContent = await file.vault.read(file);
      const content = `${title}

${fileContent}`;
      const attachmentPaths = this.extractAttachmentPaths(content);
      const formData = new FormData();
      formData.append("title", title);
      formData.append("markdown", content);
      formData.append("secret", post.secret);
      const findFileInSubdirectories = async (vault, filename) => {
        const searchInDirectory = async (directory) => {
          for (const child of directory.children) {
            if (child instanceof import_obsidian.TFile && child.name === filename) {
              return child;
            } else if (child instanceof import_obsidian.TFolder) {
              const result = await searchInDirectory(child);
              if (result)
                return result;
            }
          }
          return null;
        };
        return await searchInDirectory(vault.getRoot());
      };
      for (const path of attachmentPaths) {
        let attachmentFile = file.vault.getAbstractFileByPath(path);
        if (!(attachmentFile instanceof import_obsidian.TFile)) {
          const filename = path.split("/").pop();
          attachmentFile = await findFileInSubdirectories(file.vault, filename);
        }
        if (attachmentFile instanceof import_obsidian.TFile) {
          try {
            const attachmentContent = await attachmentFile.vault.readBinary(attachmentFile);
            const attachmentBlob = new Blob([attachmentContent]);
            formData.append("files", attachmentBlob, attachmentFile.name);
          } catch (e) {
            console.error(`Failed to read attachment: ${path}`, e);
          }
        }
      }
      try {
        await infostackerWrapper.updatePost(post.id, formData);
      } catch (e) {
        console.error(e);
        if (e instanceof FileSizeLimitError) {
          throw new FileSizeLimitError("Failed to update post");
        } else {
          throw new Error("Failed to update post");
        }
      }
    },
    async deletePost(file) {
      const formData = new FormData();
      const post = data.posts[file.path];
      formData.append("secret", post.secret);
      try {
        await infostackerWrapper.deletePost(post.id, formData);
        delete data.posts[file.path];
        await saveData(data);
      } catch (e) {
        console.error(e);
        throw new Error("Failed to delete post");
      }
    },
    extractAttachmentPaths(content) {
      const paths = [];
      const regex = /!\[\[.*?\]\]/g;
      let match;
      while ((match = regex.exec(content)) !== null) {
        paths.push(match[0].substring(3, match[0].length - 2));
      }
      return paths;
    }
  };
}

// src/text.ts
function flatten(obj) {
  const result = {};
  for (const key of Object.keys(obj)) {
    const value = obj[key];
    if (typeof value === "string") {
      result[key] = value;
    } else {
      const inner = flatten(value);
      for (const innerKey of Object.keys(inner)) {
        result[`${key}.${innerKey}`] = inner[innerKey];
      }
    }
  }
  return result;
}
var strings = flatten({
  serviceName: "Infostacker note manager",
  actions: {
    create: {
      name: "Publish to Infostacker",
      success: "Note published to Infostacker. URL copied to clipboard.",
      failure: "Failed to publish note to Infostacker",
      failureFileSizeLimit: "Failed to publish note to Infostacker: File size exceeds the 25MB limit."
    },
    update: {
      name: "Update in Infostacker",
      success: "Updated note in Infostacker. It may take a little while before update becomes visible.",
      failure: "Failed to update note in Infostacker",
      failureFileSizeLimit: "Failed to publish note to Infostacker: File size exceeds the 25MB limit."
    },
    copyUrl: {
      name: "Copy Infostacker's note URL",
      success: "Infostacker's note URL copied to clipboard",
      failure: "Note not yet published"
    },
    remove: {
      name: "Remove from Infostacker",
      success: "Note removed from Infostacker",
      failure: "Failed to remove note from Infostacker"
    },
    listPosts: {
      name: "View published posts",
      title: "Published posts",
      showFile: "View file",
      showPost: "View post"
    }
  },
  modals: {
    showUrl: {
      title: "Note published at:",
      copy: "Copy URL"
    }
  }
});
function getText(path, ...args) {
  const value = strings[path];
  if (value !== void 0) {
    if (args.length) {
      return `${value}: ${args.join(", ")}`;
    }
    return value;
  }
  return path;
}

// src/modals.ts
var import_obsidian2 = __toModule(require("obsidian"));
var PublishedPostsModal = class extends import_obsidian2.Modal {
  constructor(app, InfostackerClient) {
    super(app);
    this.InfostackerClient = InfostackerClient;
    this.app = app;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: getText("actions.listPosts.title") });
    for (const [path] of Object.entries(this.InfostackerClient.data().posts)) {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (!(file instanceof import_obsidian2.TFile)) {
        continue;
      }
      const container = this.contentEl.createEl("div", {
        cls: ["published-posts-modal", "list-item-container"]
      });
      container.createEl("span", { text: path });
      const buttonContainer = container.createEl("div");
      const showFile = buttonContainer.createEl("button", {
        title: getText("actions.listPosts.showFile")
      });
      showFile.addEventListener("click", () => this.app.workspace.openLinkText(path, path).then(() => this.close()));
      (0, import_obsidian2.setIcon)(showFile, "file-text");
      const webLink = buttonContainer.createEl("a", {
        cls: "hidden",
        href: this.InfostackerClient.getUrl(file)
      });
      const showPost = buttonContainer.createEl("button");
      showPost.addEventListener("click", () => {
        webLink.click();
        this.close();
      });
      (0, import_obsidian2.setIcon)(showPost, "globe");
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// main.ts
var InfostackerPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    this.InfostackerClient = await createClient(async () => ({
      posts: {},
      ...await this.loadData()
    }), async (data) => await this.saveData(data));
    this.addInfostackerCommands();
    this.registerFileMenuEvent();
  }
  onunload() {
  }
  addInfostackerCommands() {
    this.addCommand({
      id: "action.listPosts",
      name: getText("actions.listPosts.name"),
      callback: () => this.showPublishedPosts()
    });
    this.addCommand({
      id: "action.create",
      name: getText("actions.create.name"),
      editorCheckCallback: (checking, _, view) => {
        if (checking) {
          return !this.InfostackerClient.getUrl(view.file);
        }
        this.publishFile(view.file);
      }
    });
    this.addCommand({
      id: "action.update",
      name: getText("actions.update.name"),
      editorCheckCallback: (checking, _, view) => {
        if (checking) {
          return !!this.InfostackerClient.getUrl(view.file);
        }
        this.updateFile(view.file);
      }
    });
    this.addCommand({
      id: "action.copyUrl",
      name: getText("actions.copyUrl.name"),
      editorCheckCallback: (checking, _, view) => {
        if (checking) {
          return !!this.InfostackerClient.getUrl(view.file);
        }
        this.copyUrl(view.file);
      }
    });
    this.addCommand({
      id: "action.remove",
      name: getText("actions.remove.name"),
      editorCheckCallback: (checking, _, view) => {
        if (checking) {
          return !!this.InfostackerClient.getUrl(view.file);
        }
        this.deleteFile(view.file);
      }
    });
  }
  registerFileMenuEvent() {
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian3.TFile && file.extension === "md") {
        menu.addSeparator();
        if (!this.InfostackerClient.getUrl(file)) {
          menu.addItem((item) => item.setTitle(getText("actions.create.name")).setIcon("up-chevron-glyph").onClick(() => this.publishFile(file)));
        } else {
          menu.addItem((item) => item.setTitle(getText("actions.update.name")).setIcon("double-up-arrow-glyph").onClick(() => this.updateFile(file))).addItem((item) => item.setTitle(getText("actions.copyUrl.name")).setIcon("link").onClick(() => this.copyUrl(file))).addItem((item) => item.setTitle(getText("actions.remove.name")).setIcon("cross").onClick(() => this.deleteFile(file)));
        }
        menu.addSeparator();
      }
    }));
  }
  showPublishedPosts() {
    new PublishedPostsModal(this.app, this.InfostackerClient).open();
  }
  async publishFile(file) {
    try {
      const url = await this.InfostackerClient.createPost(file);
      await navigator.clipboard.writeText(url);
      new import_obsidian3.Notice(getText("actions.create.success"));
    } catch (e) {
      console.error(e);
      if (e instanceof FileSizeLimitError) {
        new import_obsidian3.Notice(getText("actions.create.failureFileSizeLimit"));
      } else {
        new import_obsidian3.Notice(getText("actions.create.failure"));
      }
    }
  }
  async updateFile(file) {
    try {
      await this.InfostackerClient.updatePost(file);
      new import_obsidian3.Notice(getText("actions.update.success"));
    } catch (e) {
      console.error(e);
      if (e instanceof FileSizeLimitError) {
        new import_obsidian3.Notice(getText("actions.update.failureFileSizeLimit"));
      } else {
        new import_obsidian3.Notice(getText("actions.update.failure"));
      }
    }
  }
  async copyUrl(file) {
    const url = this.InfostackerClient.getUrl(file);
    if (url) {
      await navigator.clipboard.writeText(url);
      new import_obsidian3.Notice(getText("actions.copyUrl.success"));
    } else {
      new import_obsidian3.Notice(getText("actions.copyUrl.failure"));
    }
  }
  async deleteFile(file) {
    try {
      await this.InfostackerClient.deletePost(file);
      new import_obsidian3.Notice(getText("actions.remove.success"));
    } catch (e) {
      console.error(e);
      new import_obsidian3.Notice(getText("actions.remove.failure"));
    }
  }
};


/* nosourcemap */