# Question  1

![[Pasted image 20250211225823.png]]
**Question 1a**: Show that `[p ∨ ¬(q ∨ r)]` is logically equivalent to `(p ∨ q) ∧ ¬(p ∨ r)`.

**Question 1b**: Determine if the propositional logic (PL) sentence `(A ⇒ B) ∧ ¬(A ∨ B)` is valid, a contradiction, or satisfiable.

**Question 1c**: Express `¬[Q → ((P ∧ ¬R) ∨ ¬S)]` in Negation Normal Form (NNF).

---
# Q1 Solution![[Pasted image 20250212012106.png]]
# b)![[Pasted image 20250211232520.png]]

# c)![[Pasted image 20250212000645.png]]![[Pasted image 20250212000706.png]]

---
# Question 2
![[Pasted image 20250212124418.png]]

---
# Q2 Solution 

# a)An agent is a system that processes information and produces an output from an input.
![[Pasted image 20250212124838.png]]
 

>[!gemini]+ Gemini
>## Database 🌐
> 
> **Definition:**
> 
> A database is a structured collection of 

# b) 
![[Pasted image 20250212125032.png]]![[Pasted image 20250212125256.png]]![[Pasted image 20250212125330.png]]![[Pasted image 20250212125504.png]]

# c)

>[!gemini]+ Gemini
>```obsidian
> 
> ---
> # Taxi Driver Agent PEAS
> 
> ## Performance
> - Maximize passenger satisfaction
> - Minimize journey time
> - Minimize fuel consumption
> 
> ## Environment
> - Road network with traffic conditions
> - Passenger demand (location and destination)
> - Weather conditions
> 
> ## Actuators
> - Steering wheel
> - Accelerators and brakes
> - Route planner
> 
> ## Sensors
> - GPS
> - Speedometer
> - Camera (for passenger surveillance)
> ---
> 
> ```
 

# d)![[Pasted image 20250212133245.png]]![[Pasted image 20250212133938.png]]![[Pasted image 20250212134021.png]]


# e)![[Pasted image 20250212134951.png]]

---
# Question 3
![[Pasted image 20250212135151.png]]

---
# Q3 Solution
![[Pasted image 20250212140701.png]]
![[Screenshot 2025-02-12 140725.png]]
# b)![[Pasted image 20250212141515.png]]![[Pasted image 20250212141528.png]]

# c)![[Pasted image 20250212142113.png]]![[Pasted image 20250212142234.png]]
![[Pasted image 20250212142535.png]]
# d) b
# BFS
Path :['a', 'b']
c
Path :['a', 'd', 'h', 'f', 'c']
d
Path :['a', 'd']
e
Path :['a', 'e']
f
Path :['a', 'd', 'h', 'f']
g
Path :['a', 'd', 'g']
h
Path :['a', 'd', 'h']

# DFS
b
Path :['a', 'b']
c
Path :['a', 'd', 'h', 'f', 'c']
d
Path :['a', 'd']
e
Path :['a', 'e']
f
Path :['a', 'd', 'h', 'f']
g
Path :['a', 'd', 'g']
h
Path :['a', 'd', 'h']